Monday 15/6/2020
- Setup and configured dev environment: VSCode on Windows with remote Debian WSL, configured C++ Intellisense to use g++ and boost libraries
- Figured out how to include boost and compile with g++
- Installed CMake and Native Debug VSCode plugins
- todo: test CMake compilation, test boost filesystem code, read C++ project structure webpages (see saved Firefox session 15/6)

Tues 16/6/2020
- Made decision to use std::filesystem from C++17 preferably over boost::filesystem - standard lib vs 3rd party include
- Read C++ project structure (directory layout conventions) webpages (see saved Firefox session 15/6)

Wed 17/6/2020
- Alterted directory structure to follow std form (/include, /src, /build directories)
- Configured CMakeLists.txt and correct building of project with cmake, including correct linking of std::filesystem
- Built and tested inotify-cpp library to watch a directory

Thur 18/6/2020
- Read through code of fswatch library, providing multiplatform filesystem watches - uses inotify and stat() on Linux
- Determined inotify alone is insufficient - cannot determine file changes if service is not running e.g. machine off, program crash
    - Still need a local database/log of local files, possibly though stat() or more likely std::filesystem.
    - Polling of large directories and many files will be slow. Ideal solution is inotify when service is running, with semi-regular file index polling/updates for best efficiency.
- Basic getting of file attributes with std::filesystem
    - Determine which file attributes are required
- Determine database system - sqlite? slow lookups when reading from file? hashmaps in memory, but then need to serialise to save when service not running
    - SQLite    - unencrypted db file on host, encrypt as a regular backed up file and send to host for backup
                - can be faster than I/O, small size, ACID transactions, well tested
                - SQL query language
    - file      - requires serialisation, constant I/O or bucketing of transactions
                - fast for a relatively small number of items
                - possible to do this with Boost MultiIndex MRU object cache or Boost lib serialisation

Fri 19/6/2020
- SQLite file index database connection made and libraries linked from code
- Separate FileIndex class prototype for index functions/capability
- todo: File integrity checks with hashes - as a separate background process, not when polling as will be slow otherwise
- desired feature/improvement: inotify running in addition to regular file system polling and indexdb updates

Mon 22/6/2020
- Created abstracted DB class to handle DB functions (e.g. open/close db, execute SQL code with error handling), new main class "enclone" to tie together all other classes
- enclone class includes vector of shared_pts to Watch* objects, allowing multiple watch directories to be added
    - todo: regularly save this in SQLite db for persistance on crash/restart, and restore from db on start
- DB structure - 2 tables created and initialised from code
    - WatchDirs - path
    - FileIndex - IDX/filename/path/mod time/size/file hash
- todo: populate DB with files in directory
- todo: check path is valid path before adding and error handling

Tue 23/6/2020
- Changed Watch class to have single instance with a vector of watched directories/files inside
- Added recursive params to recursively add directories to Watch if bool recursive is true
- Researching how to develop into a linux daemon/service (encloned), ability to add watch files/directories from cmd line
    - for development/testing/debugging, run daemon in foreground?
    - see project bookmarks, also see systemd
    - likely option is run binary via systemd and have it load a config file or from db for file watches etc, wrapper program can write to config/db 
    - issue with file locks with SQLite - need to ensure locks are respected/retry transactions - daemon can only read db if it notices mod time has changed