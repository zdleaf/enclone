- Comparison of libraries - https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries

Search "search-term site:crypto.stackexchange.com"

https://dl.acm.org/action/doSearch?AllField=encryption&expand=all&SeriesKey=tops

General AEAD - https://www.imperialviolet.org/2015/05/16/aeads.html

Learn about oracle based attacks (re: authentication)

Papers - see folder in root directory for full downloaded pdfs
- http://cseweb.ucsd.edu/~mihir/papers/oem.pdf
- https://www.cs.ucdavis.edu/~rogaway/papers/modes.pdf
- https://eprint.iacr.org/2015/189.pdf

Algos
- XChaCha20-Poly1305
    - uses a 192-bit nonce - see https://www.imperialviolet.org/2015/05/16/aeads.html why this is preferable over 96-bit nonce of AES-GCM

- AGE 
    - https://github.com/FiloSottile/age
    - Uses HKDF, and with ChaCha20-Poly1305, x25519 and scrypt
    - https://neilmadden.blog/2019/12/30/a-few-comments-on-age/
    - https://news.ycombinator.com/item?id=21895671
    - use as a backend?

- OpenSSL library (libcrypto - already included in project)
    - FIPS 140 and 140-2 validated - approved by US government
    - https://wiki.openssl.org/index.php/EVP
        - Envelope functions encrypts a symmetric key
    - see EVP.h for list of supported ciphers - copied to openSSL-supported-ciphers.txt
    - https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption
        - we also want to authenticate data - "Such Authenticated-Encryption with Associated-Data (AEAD) schemes provide confidentiality by encrypting the data, and also provide authenticity assurances by creating a MAC tag over the encrypted data. The MAC tag will ensure the data is not accidentally altered or maliciously tampered during transmission and storage. "
        - currently only AES is supported in modes EAX, CCM and GCM
            - GCM is faster than CCM
                - as per https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/
        - see https://en.wikipedia.org/wiki/Authenticated_encryption
        - see https://crypto.stackexchange.com/questions/12178/why-should-i-use-authenticated-encryption-instead-of-just-encryption
        - see https://www.cs.ucdavis.edu/~rogaway/papers/modes.pdf
        - see https://blog.cryptographyengineering.com/2012/05/19/how-to-choose-authenticated-encryption/
    - Code examples
        - http://www.zedwood.com/article/cpp-openssl-aes-gcm-code-sample
        - https://medium.com/@amit.kulkarni/encrypting-decrypting-a-file-using-openssl-evp-b26e0e4d28d4
            - https://github.com/kulkarniamit/openssl-evp-demo
            - this chunk in 1024 bytes (BUFSIZE var)
        - https://github.com/sailorfred/gcmcrypt
            - Command line AES256-GCM file encryption with 96 bit IV and 128 bit authentication tag
        - https://github.com/akw0088/openssl/blob/master/aes_enc.cpp

- Crypto++
    - supported ciphers - https://www.cryptopp.com/
    - benchmarks https://www.cryptopp.com/benchmarks.html
    - more stream cipher options (typically faster than block ciphers - but less secure?)
    - Authenticated Encryption schemes available - GCM, CCM, EAX, ChaCha20Poly1305, XChaCha20Poly1305
        - https://www.cryptopp.com/wiki/GCM_Mode example code
        - AES-GCM-Test.zip
    - Use XChaCha20Poly1305 (ChaCha20Poly1305 hardened against nonce misuse)
    - Can chunk files using FileSource - https://www.cryptopp.com/wiki/Pumping_Data#Encryption

- Google Tink
    - https://github.com/google/tink
    - Tink is a multi-language, cross-platform, open source library that provides cryptographic APIs that are secure, easy to use correctly, and hard(er) to misuse. 

- LibSodium (NaCL)
    - https://doc.libsodium.org/secret-key_cryptography/aead/aes-256-gcm
        - WARNING: Despite being the most popular AEAD construction due to its use in TLS, safely using AES-GCM in a different context is tricky.
        - No more than ~ 350 GB of input data should be encrypted with a given key. This is for ~ 16 KB messages -- Actual figures vary according to message sizes.
        - In addition, nonces are short and repeated nonces would totally destroy the security of this scheme. Nonces should thus come from atomic counters, which can be difficult to set up in a distributed environment.
    - Use XChaCha20-Poly1305
    - Has a stream encryption high level API call - https://libsodium.gitbook.io/doc/secret-key_cryptography/secretstream
        - this looks like the easiest implementation - split file into chunks and encrypt each chunk as per example code above




https://github.com/openssl/openssl/pull/5048
    I feel that I expressed myself clear enough, but all right. Adding AEAD support to command line, be it enc or new utility. -1. Rationale is that since most [at least most popular, if not all] AEAD ciphers fail catastrophically in case key and iv are reused, user should not be trusted with their, key and iv, management. This has actually lesser to do with "streaming" to EVP. And for this reason rationale applies even to some of the non-AEAD modes currently supported by enc, most notably counter modes and RC4. This inevitably asks for following questions.

        Should we add some kind of key-iv management to enc? I argue no, cms already does it, it's more than appropriate to use that instead. [This aligns perfectly with this merge request.]
        Should enc be removed? No, we can't do that for backward compatibility reasons.
        Should we do anything about enc? One can argue that it wouldn't be inappropriate [now or at some later point] to ban some modes from specifically enc -e [but leave enc -d alone as people are entitled to decipher old data].

    And on strongly relate note, since AEAD questions customarily are about AES-GCM, one can argue that cms should be extended to adopt RFC5084.

    'This command does not support authenticated encryption modes
    like CCM and GCM, and will not support such modes in the future.
    This is due to having to begin streaming output (e.g., to standard output
    when B<-out> is not used) before the authentication tag could be validated.
    When this command is used in a pipeline, the receiving end will not be
    able to roll back upon authentication failure. The AEAD modes currently in
    common use also suffer from catastrophic failure of confidentiality and/or
    integrity upon reuse of key/iv/nonce, and since B places the
    entire burden of key/iv/nonce management upon the user, the risk of
    exposing AEAD modes is too great to allow. These key/iv/nonce
    management issues also affect other modes currently exposed in this command,
    but the failure modes are less extreme in these cases, and the
    functionality cannot be removed with a stable release branch.
    For bulk encryption of data, whether using authenticated encryption
    modes or other modes, L<openssl-cms(1)> is recommended, as it provides a
    standard data format and performs the needed key/iv/nonce management.'

- Use a different key and iv for each file, and store in index? issue with key/iv reuse

- Cannot do streaming with AEAD? Have to get entire file contents in memory

- One can certainly make an AEAD by composing CBC and HMAC (in the right order!)

- As you've already discovered from your research, there isn't much of an elegant solution for authenticated encryption of large files.
- There are traditionally two ways to approach this problem:
    - Split the file into chunks, encrypt each chunk individually and let each chunk have its own authentication tag. AES-GCM would be the best mode to use for this. This method causes file size bloating proportionate to the size of the file. You'll also need a unique nonce for each chunk. You also need a way to indicate where chunks begin/end.
    - Encrypt using AES-CTR with a buffer, call Hash.Write on an HMAC for each buffer of encrypted data. The benefit of this is that encrypting can be done in one pass. The downside is that decryption requires one pass to validate the HMAC and then another pass to actually decrypt. The upside here is that the file size remains the same, plus roughly ~48 or so bytes for the IV and HMAC result.
